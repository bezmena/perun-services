#!/usr/bin/perl
use feature "switch";
use strict;
use warnings;
use perunServicesInit;
use perunServicesUtils;
use Time::Piece;
use JSON::XS;

sub processMembers;
sub processGroups;

#local $::SERVICE_NAME = "contoso_ad";
#local $::PROTOCOL_VERSION = "3.0.0";
#my $SCRIPT_VERSION = "3.0.0";

#perunServicesInit::init;
#my $DIRECTORY = perunServicesInit::getDirectory;
#my $data = perunServicesInit::getDataWithGroups;

my $SERVICE_NAME = "ad_mu";
my $DIRECTORY = $ARGV[1];
my $data = $ARGV[2];
print "Running contoso_ad sn: " . $SERVICE_NAME . "\n";


my $fileNameUsers = "$DIRECTORY/$SERVICE_NAME"."_users.json";
my $fileNameGroups = "$DIRECTORY/$SERVICE_NAME"."_groups.json";  # printed for each OU
my $fileNameOus = "$DIRECTORY/$SERVICE_NAME"."_ous.json";
my $baseDnFileName = "$DIRECTORY/baseDN";
my $baseDnFileNameGroups = "$DIRECTORY/baseDNGroups";
my $fileNameFID = "$DIRECTORY/facilityId";


# Constants
our $A_F_BASE_DN;  *A_F_BASE_DN = \'urn:perun:facility:attribute-def:def:adBaseDN';
our $A_F_GROUP_BASE_DN;  *A_F_GROUP_BASE_DN = \'urn:perun:facility:attribute-def:def:adGroupBaseDN';
our $A_F_DOMAIN;  *A_F_DOMAIN = \'urn:perun:facility:attribute-def:def:adDomain';
our $A_F_AZURE_DOMAIN;  *A_F_AZURE_DOMAIN = \'urn:perun:facility:attribute-def:def:adAzureDomain';
our $A_F_UAC;  *A_F_UAC = \'urn:perun:facility:attribute-def:def:adUAC';
our $A_F_ID;  *A_F_ID = \'urn:perun:facility:attribute-def:core:id';
our $A_F_O365_ALL_MAIN_LICENSES; *A_F_O365_ALL_MAIN_LICENSES = \'urn:perun:facility:attribute-def:def:o365AllMainLicenses';
our $A_F_O365_USED_MAIN_LICENSES; *A_F_O365_USED_MAIN_LICENSES = \'urn:perun:facility:attribute-def:def:o365UsedMainLicenses';

# OU, Group
our $A_R_OU_NAME;  *A_R_OU_NAME = \'urn:perun:resource:attribute-def:def:adOuName';

our $A_G_R_AD_NAME;  *A_G_R_AD_NAME = \'urn:perun:group_resource:attribute-def:def:adName';
our $A_G_R_AD_DISPLAY_NAME;  *A_G_R_AD_DISPLAY_NAME = \'urn:perun:group_resource:attribute-def:def:adDisplayName';
our $A_G_R_msExchRequireAuthToSendTo;  *A_G_R_msExchRequireAuthToSendTo = \'urn:perun:group_resource:attribute-def:def:adRequireSenderAuthenticationEnabled';
our $A_G_R_AD_EMAIL_ADDRESSES;  *A_G_R_AD_EMAIL_ADDRESSES = \'urn:perun:group_resource:attribute-def:def:o365EmailAddresses:mu';

# User/member attributes
our $A_FIRST_NAME;  *A_FIRST_NAME = \'urn:perun:user:attribute-def:core:firstName';
our $A_LAST_NAME;  *A_LAST_NAME = \'urn:perun:user:attribute-def:core:lastName';
our $A_U_MAILS;  *A_U_MAILS = \'urn:perun:user:attribute-def:def:o365EmailAddresses:mu';
our $A_LOGIN; *A_LOGIN = \'urn:perun:user_facility:attribute-def:virt:login';
our $A_M_G_O365_SEND_ON_BEHALF; *A_M_G_O365_SEND_ON_BEHALF = \'urn:perun:member_group:attribute-def:def:o365SendOnBehalf';
our $A_U_F_O365_PREFERRED_LANGUAGE; *A_U_F_O365_PREFERRED_LANGUAGE = \'urn:perun:user_facility:attribute-def:def:o365PreferredLanguage';
our $A_U_F_O365_LICENCE; *A_U_F_O365_LICENCE = \'urn:perun:user_facility:attribute-def:def:o365Licence';
our $A_MEMBER_STATUS; *A_MEMBER_STATUS = \'urn:perun:member:attribute-def:core:status';

our $MEMBERS;	*MEMBERS = \'MEMBERS';
our $STATUS_VALID;                   *STATUS_VALID =                   \'VALID';
our $CLOUD_EXTENSION_A_2; *CLOUD_EXTENSION_A_2 = \'msDS-cloudExtensionAttribute2';

# GATHER USERS
my $users;  # $users->{$login}->{ATTR} = $attrValue;
my $groups; # $groups->{ouName}->{group DN}->{ATTR} = $attrValue;
my $ous; # $ous->{ouName} = 1;

# CHECK ON FACILITY ATTRIBUTES
my %facilityAttributes = attributesToHash $data->getAttributes;

if (!defined($facilityAttributes{$A_F_BASE_DN})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_GROUP_BASE_DN})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_DOMAIN})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_UAC})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_ID})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_AZURE_DOMAIN})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_O365_ALL_MAIN_LICENSES})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_O365_USED_MAIN_LICENSES})) {
	exit 1;
}


#
# PRINT BASE_DN FILEs
#
my $baseDNUsers = "OU=Users,OU=MU,DC=contoso,DC=muni,DC=cz"; #$facilityAttributes{$A_F_BASE_DN};
my $baseDNGroups = "OU=Groups,OU=MU,DC=contoso,DC=muni,DC=cz"; #$facilityAttributes{$A_F_GROUP_BASE_DN};

open FILE,">:encoding(UTF-8)","$baseDnFileName" or die "Cannot open $baseDnFileName: $! \n";
print FILE $baseDNUsers;
close(FILE);

open FILE,">:encoding(UTF-8)","$baseDnFileNameGroups" or die "Cannot open $baseDnFileNameGroups: $! \n";
print FILE $baseDNGroups;
close(FILE);

open FILE,">:encoding(UTF-8)","$fileNameFID" or die "Cannot open $fileNameFID: $! \n";
print FILE $facilityAttributes{$A_F_ID};
close(FILE);

#
# AGGREGATE DATA ABOUT MEMBERS from all resources
#
foreach my $resourceData ($data->getChildElements) {

	my %resourceAttrs = attributesToHash $resourceData->getAttributes;

	processMembers(($resourceData->getChildElements)[1]);

}

#
# AGGREGATE DATA ABOUT GROUPS from OU resources
#
foreach my $resourceData ($data->getChildElements) {

	my %resourceAttrs = attributesToHash $resourceData->getAttributes;
	my $ouName = $resourceAttrs{$A_R_OU_NAME};

	if ($ouName) {

		# groups resources (per-each end-service)
		foreach my $groupData (($resourceData->getChildElements)[0]->getChildElements) {
			processGroups($ouName, $groupData);
		}

		# Store to the list of OUs
		$ous->{$ouName} = 1;

	}

}

#
# Process members
#
sub processMembers() {

	my $membersElement = shift;

	for my $memberData ($membersElement->getChildElements) {

		my %memberAttributes = attributesToHash $memberData->getAttributes;
		my $login = $memberAttributes{$A_LOGIN};

		#if($memberAttributes{$A_MEMBER_STATUS} eq $STATUS_VALID){ #FIXME
		if(1){

			# store users relations
			my $dn = "CN=" . $memberAttributes{$A_LOGIN} . "," . $baseDNUsers;

			# store standard user attributes
			$users->{$login}->{"DN"} = $dn;
			$users->{$login}->{$A_FIRST_NAME} = $memberAttributes{$A_FIRST_NAME};
			$users->{$login}->{$A_LAST_NAME} = $memberAttributes{$A_LAST_NAME};
			$users->{$login}->{$A_U_MAILS} = $memberAttributes{$A_U_MAILS};
			$users->{$login}->{$A_U_F_O365_PREFERRED_LANGUAGE} = $memberAttributes{$A_U_F_O365_PREFERRED_LANGUAGE};

			## process user main licence
			if (defined $memberAttributes{$A_U_F_O365_LICENCE} && $memberAttributes{$A_U_F_O365_LICENCE} ne "0") {

				my $mainLicenceKey = "CN=O365Lic_" . $memberAttributes{$A_U_F_O365_LICENCE} . "_group.muni.cz,OU=licenses," . $baseDNGroups;
				my $mainStudent2LicenceKey = "CN=O365Lic_A3s-2_group.muni.cz,OU=licenses," . $baseDNGroups;

				# In case group for student licenses exeed maximum capacity (49999), rest of the users need to be added to A3s-2 group. 
				if ($memberAttributes{$A_U_F_O365_LICENCE} eq "A3s" and keys %{$groups->{"licenses"}->{$mainLicenceKey}->{$MEMBERS}} >= 49999) {
					$groups->{"licenses"}->{$mainStudent2LicenceKey}->{$MEMBERS}->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers} = 1;
				} else {
					$groups->{"licenses"}->{$mainLicenceKey}->{$MEMBERS}->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers} = 1;
				}
				$users->{$login}->{$CLOUD_EXTENSION_A_2} = $JSON::XS::true;
			} else {
				$users->{$login}->{$CLOUD_EXTENSION_A_2} = $JSON::XS::false;
			}
		}
	}

}

#
# Process groups and its members
#
sub processGroups {

	my $ouName = shift;
	my $groupData = shift;
	my $subGroupsElement = ($groupData->getChildElements)[0];
	my $membersElement = ($groupData->getChildElements)[1];
	my %groupAttributes = attributesToHash $groupData->getAttributes;

	# process normal groups
	unless ($ouName eq 'licenses') {

		if(defined $groupAttributes{$A_G_R_AD_NAME}) {
			# create group entry
			my $key = "CN=".$groupAttributes{$A_G_R_AD_NAME}."_group.muni.cz,OU=".$ouName.",".$baseDNGroups;

			$groups->{$ouName}->{$key}->{$A_G_R_AD_NAME} = $groupAttributes{$A_G_R_AD_NAME};
			$groups->{$ouName}->{$key}->{$A_G_R_AD_DISPLAY_NAME} = $groupAttributes{$A_G_R_AD_DISPLAY_NAME};
			$groups->{$ouName}->{$key}->{$A_G_R_msExchRequireAuthToSendTo} = $groupAttributes{$A_G_R_msExchRequireAuthToSendTo};
			$groups->{$ouName}->{$key}->{$A_G_R_AD_EMAIL_ADDRESSES} = $groupAttributes{$A_G_R_AD_EMAIL_ADDRESSES};

			# resolve groups members
			for my $memberData ($membersElement->getChildElements) {
				my %memberAttributes = attributesToHash $memberData->getAttributes;

				#if ($memberAttributes{$A_MEMBER_STATUS} eq $STATUS_VALID) {  FIXME
				if (1) {
					$groups->{$ouName}->{$key}->{$MEMBERS}->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers} = 1;
					# get o365SendOnBehalf for non-license groups
					if (defined $memberAttributes{$A_M_G_O365_SEND_ON_BEHALF} and $memberAttributes{$A_M_G_O365_SEND_ON_BEHALF} == 1) {
						#FIXME ukladat DN
						#$groups->{$ouName}->{$key}->{$A_M_G_O365_SEND_ON_BEHALF}->{$memberAttributes{$A_LOGIN}."\@muni.cz"} = 1;
						$groups->{$ouName}->{$key}->{$A_M_G_O365_SEND_ON_BEHALF}->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers} = 1;
						
					}
				}
			}
		}
	#Process licence groups separately
	} else {
		# handle license groups for all main licenses
		for my $mainLicenceName (@{$facilityAttributes{$A_F_O365_USED_MAIN_LICENSES}}) {

			# create group entry
			my $key = "CN=O365Lic_" . $mainLicenceName . "_" . $groupAttributes{$A_G_R_AD_NAME} . "_group.muni.cz,OU=" . $ouName . "," . $baseDNGroups;

			$groups->{$ouName}->{$key}->{$A_G_R_AD_NAME} =			"O365Lic_" . $mainLicenceName . "_" . $groupAttributes{$A_G_R_AD_NAME};
			$groups->{$ouName}->{$key}->{$A_G_R_AD_DISPLAY_NAME} =	"O365Lic_" . $mainLicenceName . "_" . $groupAttributes{$A_G_R_AD_DISPLAY_NAME};
		}

		# resolve groups members
		for my $memberData ($membersElement->getChildElements) {
			my %memberAttributes = attributesToHash $memberData->getAttributes;

			#if ($memberAttributes{$A_MEMBER_STATUS} eq $STATUS_VALID) { FIXME
			if (defined $memberAttributes{$A_U_F_O365_LICENCE} && $memberAttributes{$A_U_F_O365_LICENCE} ne "0" && $memberAttributes{$A_U_F_O365_LICENCE} ne "Abs") {

				my $aditionalLicenceKey = "CN=O365Lic_" . $memberAttributes{$A_U_F_O365_LICENCE} . "_" . $groupAttributes{$A_G_R_AD_NAME} . "_group.muni.cz,OU=" . $ouName . "," . $baseDNGroups;

				$groups->{$ouName}->{$aditionalLicenceKey}->{$MEMBERS}->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers} = 1;
			}
		}

	}

	# process all sub-groups
	foreach my $subGroupData ($subGroupsElement->getChildElements) {
		processGroups($ouName, $subGroupData);
	}

}

####################
#
# CREATE SPECIFIC LICENSE GROUPS
#
####################
foreach my $mainLicenceName (@{$facilityAttributes{$A_F_O365_ALL_MAIN_LICENSES}}) {
	$groups->{"licenses"}->{"CN=O365Lic_" . $mainLicenceName . "_group.muni.cz,OU=licenses," . $baseDNGroups}->{$A_G_R_AD_NAME} = "O365Lic_" . $mainLicenceName;
	$groups->{"licenses"}->{"CN=O365Lic_" . $mainLicenceName . "_group.muni.cz,OU=licenses," . $baseDNGroups}->{$A_G_R_AD_DISPLAY_NAME} = "O365Lic_" . $mainLicenceName;
}

############################
#
# PRINT OUs LDIF
#
############################
my @output_ous = ();
my @ouKeys = sort keys %{$ous};
for my $key (@ouKeys) {
    my $output_ou;
	# we create OUs only in groups section !!
	$output_ou->{"dn"} = "OU=" . $key . "," . $baseDNGroups;
	$output_ou->{"ou"} = $key;
	push @output_ous, $output_ou;
}

open FILE,">:encoding(UTF-8)","$fileNameOus" or die "Cannot open $fileNameOus: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode(\@output_ous);
close FILE;


#############################
#
# PRINT GROUPs JSON
#
#############################

my @groupOus = sort keys %{$ous};
my $output_groups_ou = {};
for my $ouKey (@groupOus) {

    my @output_groups;
	if (defined $groups->{$ouKey}) {

		my $ouGroups = $groups->{$ouKey};
		my @groupKeys = sort keys %{$ouGroups};
		for my $key (@groupKeys) {

            my $output_group;
            $output_group->{"DN"} = $key;
			$output_group->{"CN"} = $groups->{$ouKey}->{$key}->{$A_G_R_AD_NAME} . "_group.muni.cz";
			$output_group->{"samAccountName"} = $groups->{$ouKey}->{$key}->{$A_G_R_AD_NAME} . "_" . $ouKey;
			$output_group->{"displayName"} = $groups->{$ouKey}->{$key}->{$A_G_R_AD_DISPLAY_NAME};
			$output_group->{"MailNickName"} = $groups->{$ouKey}->{$key}->{$A_G_R_AD_NAME};
			$output_group->{"extensionAttribute1"} = $JSON::XS::true;			
            
			my $msExchVal = $groups->{$ouKey}->{$key}->{$A_G_R_msExchRequireAuthToSendTo};
			$output_group->{"msExchRequireAuthToSendTo"} = ((defined $msExchVal and $msExchVal == 1) ? $JSON::XS::true : $JSON::XS::false);

			# get proxy addresses
            my $proxyAddresses = ($groups->{$ouKey}->{$key}->{$A_G_R_AD_EMAIL_ADDRESSES}) ? $groups->{$ouKey}->{$key}->{$A_G_R_AD_EMAIL_ADDRESSES} : ();

			my $first = 0;
			my $mail;
			my @adresses = ();
			foreach my $proxyAddress (@$proxyAddresses) {
				if ($proxyAddress) {
					if ($first == 0) {
						push @adresses, "SMTP:" . $proxyAddress;
						$mail = $proxyAddress;
						$first = 1;
					} else {
						push @adresses, "smtp:" . $proxyAddress;
					}
				}
			}
            $output_group->{"proxyAddresses"} = \@adresses;

			# print first of ProxyAddresses to mail too:
			if ($mail) {
				$output_group->{"mail"} = $mail;
			}

			if (defined $groups->{$ouKey}->{$key}->{$A_M_G_O365_SEND_ON_BEHALF}) {
				# get public delegates only when they are there
				my @publicDelegates = sort keys %{$groups->{$ouKey}->{$key}->{$A_M_G_O365_SEND_ON_BEHALF}};
				$output_group->{"publicDelegates"} = \@publicDelegates;
			}

			if (defined $groups->{$ouKey}->{$key}->{$MEMBERS}) {
				# print members only when they are there
				my @groupMembers = sort keys %{$groups->{$ouKey}->{$key}->{$MEMBERS}};
				$output_group->{"members"} = \@groupMembers;
			}
            push @output_groups, $output_group;
		}

	}
    $output_groups_ou->{$ouKey} = \@output_groups;
}
open FILE,">:encoding(UTF-8)","$fileNameGroups" or die "Cannot open $fileNameGroups: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode($output_groups_ou);
close FILE;

##################################
#
# PRINT USERs JSON
#
##################################
# FOR EACH USER ON FACILITY
my @output_users = ();
my @logins = sort keys %{$users};
for my $login (@logins) {

    my $output_user = {};
	
    # Localy defined attributes
	my $userPrincipalName = "$login\@$facilityAttributes{$A_F_DOMAIN}";
	my $samAccountName = $login;

	# print attributes, which are never empty
	$output_user->{"DN"} = $users->{$login}->{"DN"};
	$output_user->{"cn"} = $login;

	# skip attributes which are empty and LDAP can't handle it (FIRST_NAME, EMAIL)
	my $sn = $users->{$login}->{$A_LAST_NAME};
	my $givenName = $users->{$login}->{$A_FIRST_NAME};

	# print display name from firstName/lastName only
	my $printedDisplayName = undef;
	if (defined $givenName and length $givenName and defined $sn and length $sn) {
		$printedDisplayName = $givenName . " " . $sn;
	} elsif (defined $givenName and length $givenName and !(defined $sn and length $sn)) {
		$printedDisplayName = $givenName;
	} elsif (!(defined $givenName and length $givenName) and defined $sn and length $sn) {
		$printedDisplayName = $sn;
	}
	if (defined $printedDisplayName and length $printedDisplayName) {
		$output_user->{"displayName"} = $printedDisplayName;
	}

	if (defined $sn and length $sn) {
		$output_user->{"sn"} = $sn;
	}
	if (defined $givenName and length $givenName) {
		$output_user->{"givenName"} = $givenName;
	}

	if (defined $samAccountName and length $samAccountName) {
		$output_user->{"samAccountName"} = $samAccountName;
	}
	if (defined $userPrincipalName and length $userPrincipalName) {
		$output_user->{"userPrincipalName"} = $userPrincipalName;
	}
	$output_user->{"MailNickName"} = $login;

	# get proxy addresses of user
	my $proxyAddresses = ($users->{$login}->{$A_U_MAILS}) ? $users->{$login}->{$A_U_MAILS} : ();

	my $first = 0;
	my $mail;
    my @adresses = ();
	foreach my $proxyAddress (@$proxyAddresses) {
		if ($proxyAddress) {
			if ($first == 0) {
				push @adresses, "SMTP:" . $proxyAddress;
				$mail = $proxyAddress;
				$first = 1;
			} else {
				push @adresses, "smtp:" . $proxyAddress;
			}
		}
	}
    $output_user->{"proxyAddresses"} = \@adresses;

	if (defined $mail and length $mail) {
		$output_user->{"mail"} = $mail;
	}

	$output_user->{"c"} = "CZ";

	if($users->{$login}->{$A_U_F_O365_PREFERRED_LANGUAGE}) {
		$output_user->{"preferredLanguage"} = $users->{$login}->{$A_U_F_O365_PREFERRED_LANGUAGE};
	}

	$output_user->{"targetaddress"} = $login . '@mail.muni.cz';

    $output_user->{"msDS-cloudExtensionAttribute1"} = $login . '@' . $facilityAttributes{$A_F_AZURE_DOMAIN};
    $output_user->{"msDS-cloudExtensionAttribute2"} = $users->{$login}->{$CLOUD_EXTENSION_A_2};

	$output_user->{"msDS-cloudExtensionAttribute3"} = $JSON::XS::true;
	$output_user->{"userAccountControl"} = $facilityAttributes{$A_F_UAC};

	push @output_users, $output_user;
}

open FILE,">:encoding(UTF-8)","$fileNameUsers" or die "Cannot open $fileNameUsers: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode(\@output_users);
close FILE or die "Cannot close $fileNameUsers: $! \n";

#perunServicesInit::finalize;