#!/usr/bin/perl
use feature "switch";
use strict;
use warnings;
use perunServicesInit;
use perunServicesUtils;
use Time::Piece;

sub processMembers;
sub processExtendedLicenses;
sub processGroups;

local $::SERVICE_NAME = "contoso_ad";
local $::PROTOCOL_VERSION = "3.0.0";
my $SCRIPT_VERSION = "3.0.0";

perunServicesInit::init;
my $DIRECTORY = perunServicesInit::getDirectory;
my $fileNameUsers = "$DIRECTORY/$::SERVICE_NAME"."_users.json";
my $fileNameGroups = "$DIRECTORY/$::SERVICE_NAME"."_groups.json";  # printed for each OU
my $fileNameOus = "$DIRECTORY/$::SERVICE_NAME"."_ous.json";
my $baseDnFileName = "$DIRECTORY/baseDN";
my $baseDnFileNameGroups = "$DIRECTORY/baseDNGroups";
my $fileNameRelations = "$DIRECTORY/userRelations.json";
my $fileNameLicenses = "$DIRECTORY/userLicenses.json";
my $fileNameLicGroupNames = "$DIRECTORY/licGroupNames.json";
my $fileNameFID = "$DIRECTORY/facilityId";
my $fileNameManualEmployees = "$DIRECTORY/manualEmployees.json";

my $data = perunServicesInit::getDataWithGroups;

# Constants
our $A_F_BASE_DN;  *A_F_BASE_DN = \'urn:perun:facility:attribute-def:def:adBaseDN';
our $A_F_GROUP_BASE_DN;  *A_F_GROUP_BASE_DN = \'urn:perun:facility:attribute-def:def:adGroupBaseDN';
our $A_F_DOMAIN;  *A_F_DOMAIN = \'urn:perun:facility:attribute-def:def:adDomain';
our $A_F_AZURE_DOMAIN;  *A_F_AZURE_DOMAIN = \'urn:perun:facility:attribute-def:def:adAzureDomain';
our $A_F_UAC;  *A_F_UAC = \'urn:perun:facility:attribute-def:def:adUAC';
our $A_F_ID;  *A_F_ID = \'urn:perun:facility:attribute-def:core:id';

# OU, Group
our $A_R_OU_NAME;  *A_R_OU_NAME = \'urn:perun:resource:attribute-def:def:adOuName';
our $A_R_RELATION_TYPE;  *A_R_RELATION_TYPE = \'urn:perun:resource:attribute-def:def:relationType'; # STU/ZAM/ABS

our $A_G_R_AD_NAME;  *A_G_R_AD_NAME = \'urn:perun:group_resource:attribute-def:def:adName';
our $A_G_R_AD_DISPLAY_NAME;  *A_G_R_AD_DISPLAY_NAME = \'urn:perun:group_resource:attribute-def:def:adDisplayName';
our $A_G_R_msExchRequireAuthToSendTo;  *A_G_R_msExchRequireAuthToSendTo = \'urn:perun:group_resource:attribute-def:def:adRequireSenderAuthenticationEnabled';
our $A_G_R_AD_EMAIL_ADDRESSES;  *A_G_R_AD_EMAIL_ADDRESSES = \'urn:perun:group_resource:attribute-def:def:o365EmailAddresses:mu';

# User/member attributes
our $A_FIRST_NAME;  *A_FIRST_NAME = \'urn:perun:user:attribute-def:core:firstName';
our $A_LAST_NAME;  *A_LAST_NAME = \'urn:perun:user:attribute-def:core:lastName';
our $A_M_MAILS;  *A_M_MAILS = \'urn:perun:member:attribute-def:def:o365EmailAddresses:mu';
our $A_LOGIN; *A_LOGIN = \'urn:perun:user_facility:attribute-def:virt:login';
our $A_M_G_O365_SEND_ON_BEHALF; *A_M_G_O365_SEND_ON_BEHALF = \'urn:perun:member_group:attribute-def:def:o365SendOnBehalf';
our $A_U_F_O365_ACCOUNT_EXTENSION; *A_U_F_O365_ACCOUNT_EXTENSION = \'urn:perun:user_facility:attribute-def:def:o365AccountExtension';
our $A_U_F_O365_PREFERRED_LANGUAGE; *A_U_F_O365_PREFERRED_LANGUAGE = \'urn:perun:user_facility:attribute-def:def:o365PreferredLanguage';
our $A_MEMBER_STATUS; *A_MEMBER_STATUS = \'urn:perun:member:attribute-def:core:status';

our $STATUS_VALID;                   *STATUS_VALID =                   \'VALID';

# GATHER USERS
my $users;  # $users->{$login}->{ATTR} = $attrValue;
my $usersRelation; # $usersRelation->{$login}->{ZAM|STU} = 1;
my $groups; # $groups->{ouName}->{group DN}->{ATTR} = $attrValue;
my $ous; # $ous->{ouName} = 1;
my $licenses; # $licenses->{$login}->{license_group_name} = 1;
my $licGroupNames; # licGroupNames->{partLicName} = 1;
my $manualEmployees; # $manualEmployees->{user DN} = timestamp/date

# CHECK ON FACILITY ATTRIBUTES
my %facilityAttributes = attributesToHash $data->getAttributes;

if (!defined($facilityAttributes{$A_F_BASE_DN})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_GROUP_BASE_DN})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_DOMAIN})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_UAC})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_ID})) {
	exit 1;
}
if (!defined($facilityAttributes{$A_F_AZURE_DOMAIN})) {
	exit 1;
}

#
# PRINT BASE_DN FILEs
#
my $baseDNUsers = $facilityAttributes{$A_F_BASE_DN};
my $baseDNGroups = $facilityAttributes{$A_F_GROUP_BASE_DN};

open FILE,">:encoding(UTF-8)","$baseDnFileName" or die "Cannot open $baseDnFileName: $! \n";
print FILE $baseDNUsers;
close(FILE);

open FILE,">:encoding(UTF-8)","$baseDnFileNameGroups" or die "Cannot open $baseDnFileNameGroups: $! \n";
print FILE $baseDNGroups;
close(FILE);

open FILE,">:encoding(UTF-8)","$fileNameFID" or die "Cannot open $fileNameFID: $! \n";
print FILE $facilityAttributes{$A_F_ID};
close(FILE);

#
# AGGREGATE DATA ABOUT MEMBERS from all resources
#
foreach my $resourceData ($data->getChildElements) {

	my %resourceAttrs = attributesToHash $resourceData->getAttributes;
	my $relationType = $resourceAttrs{$A_R_RELATION_TYPE} || 0;

	processMembers($relationType , ($resourceData->getChildElements)[1]);

}

#
# AGGREGATE DATA ABOUT EXTENDED LICENSES (MEMBERS from all resources)
#
foreach my $resourceData ($data->getChildElements) {
	processExtendedLicenses(($resourceData->getChildElements)[1]);
}

#
# AGGREGATE DATA ABOUT GROUPS from OU resources
#
foreach my $resourceData ($data->getChildElements) {

	my %resourceAttrs = attributesToHash $resourceData->getAttributes;
	my $ouName = $resourceAttrs{$A_R_OU_NAME};

	if ($ouName) {

		# groups resources (per-each end-service)
		foreach my $groupData (($resourceData->getChildElements)[0]->getChildElements) {
			processGroups($ouName, $groupData);
		}

		# Store to the list of OUs
		$ous->{$ouName} = 1;

	}

}

#
# Process manually extended licenses
#
sub processExtendedLicenses() {

	my $membersElement = shift;

	for my $memberData ($membersElement->getChildElements) {

		my %memberAttributes = attributesToHash $memberData->getAttributes;
		my $login = $memberAttributes{$A_LOGIN};

		#if($memberAttributes{$A_MEMBER_STATUS} eq $STATUS_VALID){ #FIXME
		if(1){

			my $dn = "CN=" . $login . "," . $baseDNUsers;
			# if user has no active relation and is manually extended - put him to employees too
			if (!defined $usersRelation->{$dn}->{"ZAM"} and !defined $usersRelation->{$dn}->{"STU"} and
				defined $memberAttributes{$A_U_F_O365_ACCOUNT_EXTENSION} and length $memberAttributes{$A_U_F_O365_ACCOUNT_EXTENSION}) {
				my $currentDate = Time::Piece->strptime(localtime->ymd, "%Y-%m-%d");
				my $employeeExtendedDate = Time::Piece->strptime($memberAttributes{$A_U_F_O365_ACCOUNT_EXTENSION}, "%Y-%m-%d");
				if ($employeeExtendedDate->epoch >= $currentDate->epoch) {
					$usersRelation->{$dn}->{"ZAM"} = 1;
					$manualEmployees->{$dn} = $employeeExtendedDate->ymd;
				}
			}
		}

	}

}

#
# Process relation (STU/ZAM) and user entry only for VALID members
#
sub processMembers() {

	my $relationType = shift;
	my $membersElement = shift;

	for my $memberData ($membersElement->getChildElements) {

		my %memberAttributes = attributesToHash $memberData->getAttributes;
		my $login = $memberAttributes{$A_LOGIN};

		#if($memberAttributes{$A_MEMBER_STATUS} eq $STATUS_VALID){ #FIXME
		if(1){

			# store users relations
			my $dn = "CN=" . $memberAttributes{$A_LOGIN} . "," . $baseDNUsers;
			$usersRelation->{$dn}->{$relationType} = 1 if($relationType);  # store relation if resource define it

			# store standard user attributes
			$users->{$login}->{"DN"} = $dn;
			$users->{$login}->{$A_FIRST_NAME} = $memberAttributes{$A_FIRST_NAME};
			$users->{$login}->{$A_LAST_NAME} = $memberAttributes{$A_LAST_NAME};
			$users->{$login}->{$A_M_MAILS} = $memberAttributes{$A_M_MAILS};
			$users->{$login}->{$A_U_F_O365_PREFERRED_LANGUAGE} = $memberAttributes{$A_U_F_O365_PREFERRED_LANGUAGE};

		}
	}

}

#
# Process groups and its members
#
sub processGroups {

	my $ouName = shift;
	my $groupData = shift;
	my $subGroupsElement = ($groupData->getChildElements)[0];
	my $membersElement = ($groupData->getChildElements)[1];
	my %groupAttributes = attributesToHash $groupData->getAttributes;

	# process normal groups
	unless ($ouName eq 'licenses') {

		if(defined $groupAttributes{$A_G_R_AD_NAME}) {
			# create group entry
			my $key = "CN=".$groupAttributes{$A_G_R_AD_NAME}."_group.muni.cz,OU=".$ouName.",".$baseDNGroups;

			$groups->{$ouName}->{$key}->{$A_G_R_AD_NAME} = $groupAttributes{$A_G_R_AD_NAME};
			$groups->{$ouName}->{$key}->{$A_G_R_AD_DISPLAY_NAME} = $groupAttributes{$A_G_R_AD_DISPLAY_NAME};
			$groups->{$ouName}->{$key}->{$A_G_R_msExchRequireAuthToSendTo} = $groupAttributes{$A_G_R_msExchRequireAuthToSendTo};
			$groups->{$ouName}->{$key}->{$A_G_R_AD_EMAIL_ADDRESSES} = $groupAttributes{$A_G_R_AD_EMAIL_ADDRESSES};

			# resolve groups members
			for my $memberData ($membersElement->getChildElements) {
				my %memberAttributes = attributesToHash $memberData->getAttributes;

				#if ($memberAttributes{$A_MEMBER_STATUS} eq $STATUS_VALID) {  FIXME
				if (1) {
					$groups->{$ouName}->{$key}->{"MEMBERS"}->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers} = 1;
					# get o365SendOnBehalf for non-license groups
					if (defined $memberAttributes{$A_M_G_O365_SEND_ON_BEHALF} and $memberAttributes{$A_M_G_O365_SEND_ON_BEHALF} == 1) {
						#FIXME ukladat DN
						#$groups->{$ouName}->{$key}->{$A_M_G_O365_SEND_ON_BEHALF}->{$memberAttributes{$A_LOGIN}."\@muni.cz"} = 1;
						$groups->{$ouName}->{$key}->{$A_M_G_O365_SEND_ON_BEHALF}->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers} = 1;
						
					}
				}
			}
		}


	} else {

		# handle license groups for employees and students
		my @rels = ("Employee","Student");
		for my $rel (@rels) {

			# create group entry
			my $key = "CN=O365Lic_" . $rel . "_" . $groupAttributes{$A_G_R_AD_NAME} . "_group.muni.cz,OU=" . $ouName . "," . $baseDNGroups;

			$groups->{$ouName}->{$key}->{$A_G_R_AD_NAME} = "O365Lic_" . $rel . "_" . $groupAttributes{$A_G_R_AD_NAME};
			$groups->{$ouName}->{$key}->{$A_G_R_AD_DISPLAY_NAME} = "O365Lic_" . $rel . "_" . $groupAttributes{$A_G_R_AD_NAME};

			# store between possible partial license groups
			$licGroupNames->{$key} = 1;

			# resolve groups members
			for my $memberData ($membersElement->getChildElements) {
				my %memberAttributes = attributesToHash $memberData->getAttributes;
				#if ($memberAttributes{$A_MEMBER_STATUS} eq $STATUS_VALID) { FIXME
				if (1) {

					# if person is employee (or student+employee)
					if (defined $usersRelation->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers}->{"ZAM"}) {
						# emplyees will be placed only to employee groups
						if ($rel eq "Employee") {
							$groups->{$ouName}->{$key}->{"MEMBERS"}->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers} = 1;
						}

						# if person is only student
					} elsif (defined $usersRelation->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers}->{"STU"}) {
						# students will be placed only to student groups
						if ($rel eq "Student") {
							$groups->{$ouName}->{$key}->{"MEMBERS"}->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers} = 1;
						}
					}

					# store basic licenses of users (might contain users, which are no longer employee/student - it's resolved by send script)
					$licenses->{"CN=".$memberAttributes{$A_LOGIN}.",".$baseDNUsers}->{$groupAttributes{$A_G_R_AD_NAME}} = 1;

				}
			}

		}

	}

	# process all sub-groups
	foreach my $subGroupData ($subGroupsElement->getChildElements) {
		processGroups($ouName, $subGroupData);
	}

}

####################
#
# CREATE SPECIFIC LICENSE GROUPS
#
####################
my $key1 = "CN=O365Lic_Employee_group.muni.cz,OU=licenses," . $baseDNGroups;
$groups->{"licenses"}->{$key1}->{$A_G_R_AD_NAME} = "O365Lic_Employee";
$groups->{"licenses"}->{$key1}->{$A_G_R_AD_DISPLAY_NAME} = "O365Lic_Employee";

my $key2 = "CN=O365Lic_Student_group.muni.cz,OU=licenses," . $baseDNGroups;
$groups->{"licenses"}->{$key2}->{$A_G_R_AD_NAME} = "O365Lic_Student";
$groups->{"licenses"}->{$key2}->{$A_G_R_AD_DISPLAY_NAME} = "O365Lic_Student";

foreach my $mem (sort keys %{$usersRelation}) {

	if (defined $usersRelation->{$mem}->{"ZAM"}) {
		$groups->{"licenses"}->{$key1}->{"MEMBERS"}->{$mem} = 1;
	} elsif (defined $usersRelation->{$mem}->{"STU"}) {
		$groups->{"licenses"}->{$key2}->{"MEMBERS"}->{$mem} = 1;
	}

}

# this group members are resolved by the send script !!
my $key3 = "CN=O365Lic_Alumni_group.muni.cz,OU=licenses," . $baseDNGroups;
$groups->{"licenses"}->{$key3}->{$A_G_R_AD_NAME} = "O365Lic_Alumni";
$groups->{"licenses"}->{$key3}->{$A_G_R_AD_DISPLAY_NAME} = "O365Lic_Alumni";

my $key4 = "CN=O365Lic_Student2_group.muni.cz,OU=licenses," . $baseDNGroups;
$groups->{"licenses"}->{$key4}->{$A_G_R_AD_NAME} = "O365Lic_Student2";
$groups->{"licenses"}->{$key4}->{$A_G_R_AD_DISPLAY_NAME} = "O365Lic_Student2";

############################
#
# PRINT OUs JSON
#
############################
my @output_ous = ();
my $output_ou;
my @ouKeys = sort keys %{$ous};
for my $key (@ouKeys) {
	$output_ou = {};
	# we create OUs only in groups section !!
	$output_ou->{"dn"} = $key . "," . $baseDNGroups;
	$output_ou->{"ou"} = $key;
	push @output_ous, $output_ou;
}

open FILE,">:encoding(UTF-8)","$fileNameOus" or die "Cannot open $fileNameOus: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode(\@output_ous);
close FILE;


#############################
#
# PRINT GROUPs JSON
#
#############################

my @groupOus = sort keys %{$ous};
my $output_groups_ou = {};
my @output_groups;
my $output_group;
for my $ouKey (@groupOus) {

	@output_groups = ();
	if (defined $groups->{$ouKey}) {

		my $ouGroups = $groups->{$ouKey};
		my @groupKeys = sort keys %{$ouGroups};
		for my $key (@groupKeys) {
			$output_group = {};
			$output_group->{"DN"} = $key;
			$output_group->{"CN"} = $groups->{$ouKey}->{$key}->{$A_G_R_AD_NAME} . "_group.muni.cz";
			$output_group->{"samAccountName"} = $groups->{$ouKey}->{$key}->{$A_G_R_AD_NAME} . "_" . $ouKey;
			$output_group->{"displayName"} = $groups->{$ouKey}->{$key}->{$A_G_R_AD_DISPLAY_NAME};
			$output_group->{"MailNickName"} = $groups->{$ouKey}->{$key}->{$A_G_R_AD_NAME};
			$output_group->{"extensionAttribute1"} = "True";

			my $msExchVal = $groups->{$ouKey}->{$key}->{$A_G_R_msExchRequireAuthToSendTo};
			$output_group->{"msExchRequireAuthToSendTo"} = ((defined $msExchVal and $msExchVal == 1) ? 'TRUE' : 'FALSE');

			# get proxy addresses
			my $proxyAddresses = ($groups->{$ouKey}->{$key}->{$A_G_R_AD_EMAIL_ADDRESSES}) ? $groups->{$ouKey}->{$key}->{$A_G_R_AD_EMAIL_ADDRESSES} : ();

			my $first = 0;
			my $mail;
			my @adresses = ();
			my $proxyAddress;
			foreach $proxyAddress (@$proxyAddresses) {
				if ($proxyAddress) {
					if ($first == 0) {
						push @adresses, "SMTP:" . $proxyAddress;
						$mail = $proxyAddress;
						$first = 1;
					} else {
						push @adresses, "smtp:" . $proxyAddress;
					}
				}
			}
			$output_group->{"proxyAddresses"} = \@adresses;

			# print first of ProxyAddresses to mail too:
			if ($mail) {
				$output_group->{"mail"} = $mail;
			}

			if (defined $groups->{$ouKey}->{$key}->{$A_M_G_O365_SEND_ON_BEHALF}) {
				# get public delegates only when they are there
				my @publicDelegates = sort keys %{$groups->{$ouKey}->{$key}->{$A_M_G_O365_SEND_ON_BEHALF}};
				$output_group->{"publicDelegates"} = \@publicDelegates;		
			}

			if (defined $groups->{$ouKey}->{$key}->{"MEMBERS"}) {
				# print members only when they are there
				my @groupMembers = sort keys %{$groups->{$ouKey}->{$key}->{"MEMBERS"}};
				$output_group->{"members"} = \@groupMembers;		
			}

			push @output_groups, $output_group;
		}

	}
	$output_groups_ou->{$ouKey} = \@output_groups;	
}
open FILE,">:encoding(UTF-8)","$fileNameGroups" or die "Cannot open $fileNameGroups: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode($output_groups_ou);
close FILE;


##################################
#
# PRINT USERs JSON
#
##################################
# FOR EACH USER ON FACILITY
my @output_users;
my @logins = sort keys %{$users};
my $output_user = {};
for my $login (@logins) {
	$output_user = {};
	# Localy defined attributes
	my $userPrincipalName = "$login\@$facilityAttributes{$A_F_DOMAIN}";
	my $samAccountName = $login;

	# print attributes, which are never empty
	$output_user->{"DN"} = $users->{$login}->{"DN"};
	$output_user->{"cn"} = $login;

	# skip attributes which are empty and LDAP can't handle it (FIRST_NAME, EMAIL)
	my $sn = $users->{$login}->{$A_LAST_NAME};
	my $givenName = $users->{$login}->{$A_FIRST_NAME};

	# print display name from firstName/lastName only
	my $printedDisplayName = undef;
	if (defined $givenName and length $givenName and defined $sn and length $sn) {
		$printedDisplayName = $givenName . " " . $sn;
	} elsif (defined $givenName and length $givenName and !(defined $sn and length $sn)) {
		$printedDisplayName = $givenName;
	} elsif (!(defined $givenName and length $givenName) and defined $sn and length $sn) {
		$printedDisplayName = $sn;
	}
	if (defined $printedDisplayName and length $printedDisplayName) {
		$output_user->{"displayName"} = $printedDisplayName;
	}

	if (defined $sn and length $sn) {
		$output_user->{"sn"} = $sn;
	}
	if (defined $givenName and length $givenName) {
		$output_user->{"givenName"} = $givenName;
	}

	if (defined $samAccountName and length $samAccountName) {
		$output_user->{"samAccountName"} = $samAccountName;
	}
	if (defined $userPrincipalName and length $userPrincipalName) {
		$output_user->{"userPrincipalName"} = $userPrincipalName;
	}
	$output_user->{"MailNickName"} = $login;

	# get proxy addresses of user
	my $proxyAddresses = ($users->{$login}->{$A_M_MAILS}) ? $users->{$login}->{$A_M_MAILS} : ();

	my $first = 0;
	my $mail;
	my @adresses = ();
	my $proxyAddress;
	foreach $proxyAddress (@$proxyAddresses) {
		if ($proxyAddress) {
			if ($first == 0) {
				push @adresses, "SMTP:" . $proxyAddress;
				$mail = $proxyAddress;
				$first = 1;
			} else {
				push @adresses, "smtp:" . $proxyAddress;
			}
		}
	}
	$output_user->{"proxyAddresses"} = \@adresses;


	if (defined $mail and length $mail) {
		$output_user->{"mail"} = $mail;
	}

	$output_user->{"c"} = "CZ";

	if($users->{$login}->{$A_U_F_O365_PREFERRED_LANGUAGE}) {
		$output_user->{"preferredLanguage"} = $users->{$login}->{$A_U_F_O365_PREFERRED_LANGUAGE};
	}

	$output_user->{"targetaddress"} = $login . '@mail.muni.cz';
	$output_user->{"msDS-cloudExtensionAttribute1"} = $login . '@' . $facilityAttributes{$A_F_AZURE_DOMAIN};

	# msDS-cloudExtensionAttribute2 - is set in send script based on resulting o365 licenses

	$output_user->{"msDS-cloudExtensionAttribute3"} = "TRUE";
	$output_user->{"userAccountControl"} = $facilityAttributes{$A_F_UAC};

push @output_users, $output_user;
}

open FILE,">:encoding(UTF-8)","$fileNameUsers" or die "Cannot open $fileNameUsers: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode(\@output_users);
close FILE or die "Cannot close $fileNameUsers: $! \n";

########################################
#
# PRINT USERS RELATIONS (ZAM or STU)
#
########################################
my @output_relations = ();
foreach my $login (sort keys %{$usersRelation}) {
	my $output_relation = {};
	my @rels = sort keys %{$usersRelation->{$login}};
	if (@rels) {
		$output_relation->{$login} = \@rels;
		push @output_relations, $output_relation;
	}
}
open FILE,">:encoding(UTF-8)","$fileNameRelations" or die "Cannot open $fileNameRelations: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode(\@output_relations);
close FILE or die "Cannot close $fileNameRelations: $! \n";

########################################
#
# PRINT USERS LICENSES (Planner,Yammer,PowerBl,....)
#
########################################
my @output_licences = ();
my $output_licence;
foreach my $login (sort keys %{$licenses}) {
	$output_licence = {};
	my @rels = sort keys %{$licenses->{$login}};
	$output_licence->{$login} = \@rels;
	push @output_licences, $output_licence;
}
open FILE,">:encoding(UTF-8)","$fileNameLicenses" or die "Cannot open $fileNameLicenses: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode(\@output_licences);
close FILE or die "Cannot close $fileNameLicenses: $! \n";


########################################
#
# PRINT AVAILABLE LICENSES (Planner,Yammer,PowerBl,....)
#
########################################
my @groupCN = sort keys %{$licGroupNames};
open FILE,">:encoding(UTF-8)","$fileNameLicGroupNames" or die "Cannot open $fileNameLicGroupNames: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode(\@groupCN);
close FILE or die "Cannot close $fileNameLicGroupNames: $! \n";


########################################
#
# PRINT MANUAL EMPLOYEES with expiration timestamp (Y-M-D).
#
########################################
my @output_manualem = ();
foreach my $dn (sort keys %{$manualEmployees}) {
	push @output_manualem, {$dn => $manualEmployees->{$dn}};
}
open FILE,">:encoding(UTF-8)","$fileNameManualEmployees" or die "Cannot open $fileNameManualEmployees: $! \n";
print FILE JSON::XS->new->utf8->pretty->encode(\@output_manualem);
close FILE or die "Cannot close $fileNameManualEmployees: $! \n";

perunServicesInit::finalize;
